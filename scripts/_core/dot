#!/usr/bin/env zsh

dot() {
    if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        docs::parse "$@"
    fi

    local args=("$@")
    local extra_args=()
    local length=${#args[@]}
    args::has_no_args "$@"
    local has_no_args=$?

    while [ $length -gt 0 ]; do
        # Try current args as full path
        if script_exist "${args[@]}"; then
            "$(build_path "${args[@]}")" "${extra_args[@]}"
            return $?
        fi

        # Move last argument to extra_args and try again
        if [ -n "$BASH_VERSION" ]; then
            # Bash: 0-indexed arrays
            local last_idx=$((length - 1))
            extra_args=("${args[$last_idx]}" "${extra_args[@]}")
            args=("${args[@]:0:$last_idx}")
        elif [ -n "$ZSH_VERSION" ]; then
            # Zsh: 1-indexed arrays (by default)
            extra_args=("${args[$length]}" "${extra_args[@]}")
            args=("${args[@]:0:$((length - 1))}")
        fi
        length=${#args[@]}
    done

    local command="$(fzf_prompt "${extra_args[@]}")"
    eval "$command --help"

    if [ -n "$ZSH_VERSION" ]; then
        print -z -- "$command "
    elif [ -n "$BASH_VERSION" ]; then
        # In bash, we can't use print -z, so just output to stdout
        echo "$command"
    fi
}

list_scripts_and_contexts() {
    find "$1" -mindepth 1 -maxdepth 1 ! -name '_*' | sort -u
}

fzf_prompt() {
    local scripts_base="${DOTFILES_PATH}/scripts"
    # Find all script files recursively, excluding _* files and directories
    local all_scripts=$(find "$scripts_base" -type f ! -name "_*" ! -path "*/_*" | sort -u)
    local option_path="$(
        echo "$all_scripts" |
            while read -r full_path; do
                # Convert path to command name: /path/to/scripts/git/commit_message -> git commit_message
                local cmd_name=$(echo "$full_path" | sed "s|^${scripts_base}/||" | tr '/' ' ')
                echo -e "$full_path\t$cmd_name"
            done |
            fzf \
                --query="$*" \
                --height 100% \
                --with-nth=2 \
                --delimiter='\t' \
                --preview='p=$(echo {} | cut -f1); "$p" -h 2>/dev/null || echo "No help available"' |
            cut -f1
    )"

    if [[ -z "$option_path" ]]; then
        return 1
    fi

    # Convert the selected path back to command arguments
    local cmd_args=$(echo "$option_path" | sed "s|^${scripts_base}/||" | tr '/' ' ')
    echo "dot $cmd_args"
}

script_exist() {
    [[ -f "$(build_path "$@")" ]]
}

context_exist() {
    [[ -d "$(build_path "$@")" ]]
}

build_path() {
    echo "${DOTFILES_PATH}/scripts$(printf "/%s" "$@")"
}
