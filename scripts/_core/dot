#!/usr/bin/env zsh

dot() {
    if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        docs::parse "$@"
    fi

    local args=("$@")
    local extra_args=()
    local length=${#args[@]}
    args::has_no_args "$@"
    local has_no_args=$?

    while [ $length -gt 0 ]; do
        # Try current args as full path
        if script_exist "${args[@]}"; then
            eval "$(build_path "${args[@]}") ${extra_args[*]}"
            return $?
        fi

        if context_exist "${args[@]}"; then
            if [ ${#extra_args[@]} -gt 0 ]; then
                system::print_error "Script or context not found"
                return 1
            fi

            print -z -- "$(fzf_prompt "${args[@]}")"

            return $?
        fi

        # Move last argument to extra_args and try again
        extra_args=("${args[-1]}" "${extra_args[@]}")
        args=(${args[1, $((length - 1))]})
        length=${#args[@]}
    done

    if [[ $has_no_args -eq 0 ]]; then
        print -z -- "$(fzf_prompt)"
        return 0
    fi

    system::print_error "Script or context not found"
}

list_scripts_and_contexts() {
    find "$1" -mindepth 1 -maxdepth 1 ! -name '_*' | sort -u
}

fzf_prompt() {
    local scripts_base="${DOTFILES_PATH}/scripts"
    # Find all script files recursively, excluding _* files and directories
    local all_scripts=$(find "$scripts_base" -type f ! -name "_*" ! -path "*/_*" | sort -u)
    local option_path="$(
        echo "$all_scripts" |
            while read -r full_path; do
                # Convert path to command name: /path/to/scripts/git/commit_message -> git commit_message
                local cmd_name=$(echo "$full_path" | sed "s|^${scripts_base}/||" | tr '/' ' ')
                echo -e "$full_path\t$cmd_name"
            done |
            fzf \
                --height 100% \
                --with-nth=2 \
                --delimiter='\t' \
                --preview='p=$(echo {} | cut -f1); "$p" -h 2>/dev/null || echo "No help available"' |
            cut -f1
    )"

    if [[ -z "$option_path" ]]; then
        return 1
    fi

    # Convert the selected path back to command arguments
    local cmd_args=$(echo "$option_path" | sed "s|^${scripts_base}/||" | tr '/' ' ')
    echo "dot $cmd_args"
}

script_exist() {
    [[ -f "$(build_path "$@")" ]]
}

context_exist() {
    [[ -d "$(build_path "$@")" ]]
}

build_path() {
    echo "${DOTFILES_PATH}/scripts$(printf "/%s" "$@")"
}
